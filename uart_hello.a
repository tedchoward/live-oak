; --- LCD Hello ---

        !to "uart_hello.bin", plain
        !cpu w65c02
        * = $8000

; --- ACIA Registers ---
!addr ACIA_DATA     = $4400
!addr ACIA_STATUS   = $4401
!addr ACIA_COMMAND  = $4402
!addr ACIA_CONTROL  = $4403

; --- VIA Registers ---
!addr PORTB = $6000
!addr PORTA = $6001
!addr DDRB  = $6002
!addr DDRA  = $6003
!addr T1CL  = $6004
!addr T1CH  = $6005
!addr ACR   = $600B
!addr IFR   = $600D
!addr IER   = $600E

; --- LCD Control Bits ---
E  = %10000000
RW = %01000000
RS = %00100000

; --- Zero Page ---
!addr ticks     = $00  ; 4 bytes ($00 - $03)
!addr wait      = $04
!addr a_reg     = $05
!addr x_reg     = $05
!addr y_reg     = $06
!addr s_reg     = $07
!addr sp_reg    = $08
!addr pc_reg    = $09  ; 2 bytes ($09 - $0A)
!addr buffer    = $0B  ; 22 bytes ($0B - $22)
!addr hi_hex    = $23
!addr lo_hex    = $24
!addr sbuf_eof  = $25
!addr str_vec   = $26 ; 2 bytes ($26 - $27)
!addr start_adr = $28 ; 2 bytes ($28 - $29)
!addr length    = $2A

!addr SERIAL_BUFFER = $0200

prompt_ch = $AF


reset:      ldx #$FF
            txs

            jsr uart_init
            jsr timer_init
            jsr lcd_init

            lda #$01
            sta $3000
            lda #$02
            sta $3001
            lda #$03
            sta $3002
            lda #$04
            sta $3003
            lda #$05
            sta $3004
            lda #$06
            sta $3005
            lda #$07
            sta $3006
            lda #$08
            sta $3007

            lda #$10
            ldx #$5A
            ldy #$B7

            lda #<welcome
            sta str_vec
            lda #>welcome
            sta str_vec + 1
            jsr print_str

            ; jsr store_registers

            ; lda #<print_reg_msg
            ; sta str_vec
            ; lda #>print_reg_msg
            ; sta str_vec + 1
            ; jsr print_str

            ; lda #<buffer
            ; sta str_vec
            ; lda #>buffer
            ; sta str_vec + 1
            ; jsr print_str

print_prompt:
            lda #prompt_ch  ; '»'
            jsr put_chr
            lda #$20        ; ' '
            jsr put_chr

loop:       jsr poll_chr  ; read character from uart
            bcc +         ; if a character was read,
            pha
            sta hi_hex
            sta lo_hex
            jsr convert_to_hex
            lda hi_hex
            jsr print_ch  ; print the character to LCD
            lda lo_hex
            jsr print_ch  ; print the character to LCD
            lda #$20      ; ' ' character
            jsr print_ch  ; print the character to LCD
            pla
            cmp #$0D      ; is it a '\r'
            bne buffer_ch
            jsr execute_stmt
            jmp loop
buffer_ch:  ldx sbuf_eof
            sta SERIAL_BUFFER,x
            inc sbuf_eof
            jsr put_chr
+           jmp loop

wait_tick:  pha
            lda ticks
            sta wait
-           lda ticks
            cmp wait
            beq -
            pla
            rts

; Prints a null terminated string to the UART
; String location should be stored in vector str_vec
print_str:  phy
            pha
            ldy #$00
-           lda (str_vec),y
            beq +
            jsr put_chr   ; send the character to the UART
            iny
            jmp -
+           pla
            ply
            rts

execute_stmt:
            lda #$0D              ; '/r'
            jsr put_chr
            lda #$0A              ; '/n'
            jsr put_chr

            ldx sbuf_eof          ; null-terminate `SERIAL_BUFFER`
            stz SERIAL_BUFFER,x   ; so we can use `print_str`

            ldx #0                ; if the buffer is empty,
            cpx sbuf_eof          ; do nothing and print another prompt
            beq .print_prompt

            lda SERIAL_BUFFER,x   ; get the first character
            cmp #"r"
            bne .print_mem        ; if not "r" skip to next command

            inx
            lda SERIAL_BUFFER,x   ; get the second character
            bne .print_buf        ; if there's anything after the "r", this is
                                  ; not the print_registers command
            jsr store_registers
            jsr print_registers
            jmp .print_prompt

.print_mem: cmp #"m"              ; syntax: `m <address> [<length>]`
            bne .print_buf        ; if not "m" skip to next command
            ; parse arguments
            inx
            lda SERIAL_BUFFER,x
            cmp #" "
            bne .print_buf
            inx
            lda SERIAL_BUFFER,x
            sta hi_hex
            inx
            lda SERIAL_BUFFER,x
            sta lo_hex
            jsr from_hex
            sta start_adr+1
            inx
            lda SERIAL_BUFFER,x
            sta hi_hex
            inx
            lda SERIAL_BUFFER,x
            sta lo_hex
            jsr from_hex
            sta start_adr
            inx
            lda SERIAL_BUFFER,x
            beq .print_buf
            cmp #" "
            bne .print_buf
            inx
            lda SERIAL_BUFFER,x
            sta hi_hex
            inx
            lda SERIAL_BUFFER,x
            sta lo_hex
            jsr from_hex
            sta length
            jsr print_memory
            jmp .print_prompt

.print_buf: lda #<SERIAL_BUFFER
            sta str_vec
            lda #>SERIAL_BUFFER
            sta str_vec + 1
            jsr print_str

            lda #$0D              ; '/r'
            jsr put_chr
            lda #$0A              ; '/n'
            jsr put_chr
.print_prompt:
            lda #prompt_ch        ; '»'
            jsr put_chr
            lda #$20              ; ' '
            jsr put_chr
            stz sbuf_eof
            rts

; sprintf(buffer, "; %4x %2x %2x %2 %2x %2x\n", pc, sr, ac, xr, yr, sp);
store_registers:
            php
            pha
            phx
            phy
            lda #$3B            ; ';' character
            sta buffer
            lda #$20            ; ' ' character
            sta buffer + 1
            tsx
            inx                 ; now pointing at Y
            inx                 ; now pointing at X
            inx                 ; now pointing at A
            inx                 ; now pointing at SR
            inx                 ; now pointing at PC (low)
            inx                 ; now pointing at PC (high)
            lda $100,x          ; high byte of PC
            sta hi_hex
            sta lo_hex
            jsr convert_to_hex
            lda hi_hex
            sta buffer + 2
            lda lo_hex
            sta buffer + 3
            dex                 ; now pointing at PC (low)
            lda $100,x          ; low byte of PC
            sta hi_hex
            sta lo_hex
            jsr convert_to_hex
            lda hi_hex
            sta buffer + 4
            lda lo_hex
            sta buffer + 5
            lda #$20            ; ' ' character
            sta buffer + 6
            dex                 ; now pointing at SR
            lda $100,x
            sta hi_hex
            sta lo_hex
            jsr convert_to_hex
            lda hi_hex
            sta buffer + 7
            lda lo_hex
            sta buffer + 8
            lda #$20            ; ' ' character
            sta buffer + 9
            dex                 ; now pointing at A
            lda $100,x
            sta hi_hex
            sta lo_hex
            jsr convert_to_hex
            lda hi_hex
            sta buffer + 10
            lda lo_hex
            sta buffer + 11
            lda #$20            ; ' ' character
            sta buffer + 12
            dex                 ; now pointing at X
            lda $100,x
            sta hi_hex
            sta lo_hex
            jsr convert_to_hex
            lda hi_hex
            sta buffer + 13
            lda lo_hex
            sta buffer + 14
            lda #$20            ; ' ' character
            sta buffer + 15
            dex                 ; now pointing at Y
            lda $100,x
            sta hi_hex
            sta lo_hex
            jsr convert_to_hex
            lda hi_hex
            sta buffer + 16
            lda lo_hex
            sta buffer + 17
            lda #$20            ; ' ' character
            sta buffer + 18
            inx
            inx
            inx
            inx
            inx                 ; original value of SP
            stx hi_hex
            stx lo_hex
            jsr convert_to_hex
            lda hi_hex
            sta buffer + 19
            lda lo_hex
            sta buffer + 20
            lda #$0D            ; '\r'
            sta buffer + 21
            lda #$0A            ; '\n'
            sta buffer + 22
            stz buffer + 23     ; null terminated string
            ply
            plx
            pla
            plp
            rts

print_registers:
            pha
            lda #<print_reg_msg
            sta str_vec
            lda #>print_reg_msg
            sta str_vec + 1
            jsr print_str

            lda #<buffer
            sta str_vec
            lda #>buffer
            sta str_vec + 1
            jsr print_str
            pla
            rts

; prints `length` (8-bits) bytes starting at `start_adr` (16-bits)

print_memory:
            phy
            pha
            ldy #$00

            ; add the current index to the start address
            ; this is used for printing the start address of each line
.prt_line:
            tya
            and #$F8
            sta a_reg
            cpy a_reg
            bne .prt_byte
            lda #"\r"
            jsr put_chr
            lda #"\n"
            jsr put_chr
            clc
            tya
            adc start_adr
            pha

            lda #$00
            adc start_adr+1

            sta hi_hex
            sta lo_hex
            jsr convert_to_hex
            lda hi_hex
            jsr put_chr
            lda lo_hex
            jsr put_chr

            pla
            sta hi_hex
            sta lo_hex
            jsr convert_to_hex
            lda hi_hex
            jsr put_chr
            lda lo_hex
            jsr put_chr
            lda #":"
            jsr put_chr
            lda #" "
            jsr put_chr

.prt_byte:
            lda (start_adr),y
            sta hi_hex
            sta lo_hex
            jsr convert_to_hex
            lda hi_hex
            jsr put_chr
            lda lo_hex
            jsr put_chr
            lda #$20            ; ' ' character
            jsr put_chr
            iny
            inx
            cpy length
            bne .prt_line
            lda #"\r"
            jsr put_chr
            lda #"\n"
            jsr put_chr
            pla
            ply
            rts


convert_to_hex:
            phy
            pha
            lsr hi_hex
            lsr hi_hex
            lsr hi_hex
            lsr hi_hex
            ldy hi_hex
            lda hex_lookup,y
            sta hi_hex
            lda lo_hex
            and #$0F
            tay
            lda hex_lookup,y
            sta lo_hex
            pla
            ply
            rts


; convert the 2-digit hexadecimal string stored in hi_hex and lo_hex to it's
; value. Stores the result in A
from_hex:   lda hi_hex
            jsr from_hex_digit
            asl
            asl
            asl
            asl
            sta hi_hex
            lda lo_hex
            jsr from_hex_digit
            ora hi_hex
            rts

; Convert the value in A from a hexadecimal digit string to it's value
from_hex_digit:
            sta a_reg
            and #$DF      ; clear bit 5. Will make an lowercase letter uppercase
            sec
            sbc #$41      ; 'A'
            bcs .af       ; if >= 0 goto .af
            sec           ; else try '0'-'9'
            lda a_reg
            sbc #$30      ; '0'
            bcc .err      ; if < 0 goto err
            clc
            jmp .end
.af:        clc
            adc #$0A
            cmp #$10      ; if <= $10 we have a valid byte
            bcc .end      ; else not A-F
.err:       sec           ; set the carry flag to indicate an error
.end:       rts



welcome:    !raw "I'm a computer!\r\n\0"

hex_lookup: !raw "0123456789ABCDEF"

print_reg_msg:
            !raw "   pc  sr ac xr yr sp\r\n\0"


lcd_init:   lda #%11111111  ; Set all pins on port B to output
            sta DDRB
            lda #%11100000  ; Set top 3 pins on port A to output
            sta DDRA

            lda #%00111000  ; Set 8bit mode; 2-line display; 5x8 font
            jsr lcd_inst

            lda  #%00001110 ; Disply on, Cursor on; blink off
            jsr lcd_inst

            lda #%00000110  ; Increent and shift cursor; don't shift display
            jsr lcd_inst

            jsr lcd_clear

lcd_wait:   pha
            lda #%00000000  ; port B is input
            sta DDRB
lcd_busy:   lda #RW
            sta PORTA
            lda #(RW | E)
            sta PORTA
            lda PORTB
            and #%10000000
            bne lcd_busy

            lda #RW
            sta PORTA
            lda #%11111111  ; port B is output
            sta DDRB
            pla
            rts

lcd_inst:   jsr lcd_wait
            sta PORTB
            lda #0          ; Clear Rs/RW/E bits
            sta PORTA
            lda #E          ; Set E bit to send instruction
            sta PORTA
            lda #0          ; Clear Rs/RW/E bits
            sta PORTA
            rts

print_ch:   pha
            jsr lcd_wait
            sta PORTB
            lda #RS         ; Set RS; Clear RW/E bits
            sta PORTA
            lda #(RS | E)   ; Set E bit to send instruction
            sta PORTA
            lda #RS         ; Clear E bit
            sta PORTA
            pla
            rts

lcd_clear:  lda #%00000001  ; Cleardisplay
            jsr lcd_inst
            rts

uart_init:  lda #%00011110  ; 1 stop bit; WL=8; baud; 9600
            sta ACIA_CONTROL
            lda #%00001011  ; no parity; echo off; interrupt off; DTR active low
            sta ACIA_COMMAND
            stz sbuf_eof
            rts

put_chr:    sta ACIA_DATA
            jsr wait_tick
            rts

poll_chr:   clc             ; carry flag will be clear if not char ready
            lda ACIA_STATUS
            and #%00001000  ; is receiver data register full?
            beq +           ; if not, rts (don't wait)
            lda ACIA_DATA
            sec             ; set the carry flag if we got a character
+           rts

timer_init: lda #0
            sta ticks
            sta ticks + 1
            sta ticks + 2
            sta ticks + 3
            lda #%01000000  ; T1 continuous interrupt ; PB7 disabled
            sta ACR
            lda #$0E        ; Set the counter to (n + 2) = 10,000 µs
            sta T1CL        ; 9,998 = $270E
            lda #$27
            sta T1CH
            lda #%11000000  ; enable Timer 1 interrupts
            sta IER
            cli
            rts

irq:        bit T1CL        ; reading clears the interrupt
            inc ticks
            bne +
            inc ticks + 1
            bne +
            inc ticks + 2
            bne +
            inc ticks + 3
+           rti

          * = $FFFC
          !word reset
          !word irq
